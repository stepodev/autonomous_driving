\documentclass[a4paper, 12pt, titlepage]{scrartcl}  
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage[toc,title,page]{appendix} % Anhang 

\usepackage{listings}  % zum Codeeinbinden, Doku: http://users.ecs.soton.ac.uk/srg/softwaretools/document/start/listings.pdf
\lstdefinestyle{customcpp}{
	belowcaptionskip=1\baselineskip,
	title=\lstname,
	breaklines=true,
	keepspaces=true, 
	flexiblecolumns=true,
	tabsize=2, % ein tab = 2 spaces
	numbers=left,
	frame=leftline,
	language=C++,
	showstringspaces=false 
}

\pagenumbering{arabic} 
\usepackage{graphicx}
\usepackage[onehalfspacing]{setspace}
\usepackage[left=3cm,right=3cm,top=2.5cm,bottom=2.5cm,includeheadfoot]{geometry}

\begin{document}	
\author{Supercoole Kinder}
\title{Projektdokumentation} 
\publishers{Humboldt-Universit\"at zu Berlin}
\maketitle
\tableofcontents

\part{Projektdokumentation}
	\section{Projektbeschreibung} % Ziele und Motivation, warum das alles so toll ist. (umweltfreundlich, super Auslastung, weniger Unfälle... besonderes feature: car2car kommunikation)
		Im Rahmen des Semesterprojekts 'Hochautomatisiertes Fahren' an der Humboldt-Universität zu Berlin haben sich mehrere Studenten, verteilt auf drei parallel arbeitende Gruppen, 
		mit dem Problem beschäftigt, drei Modellfahrzeuge automatisiert in einer Kolonne fahren zu lassen. 
		Dabei gibt das führende Fahrzeug Geschwindigkeit und Richtung vor. Der Gedanke hinter dieser Problemstellung ist, 
		den Verkehrsfluss in Szenarien wie zum Beispiel auf der Autobahn effizienter und sicherer zu gestalten. 
		Im Idealfall spart die Kolonnen-Fahrweise aufgrund der Ausnutzung des Windschattens Ressourcen wie Benzin. 
		Zudem wird erhofft, dass sich durch die zeitweilige Übernahme der Steuerung durch das Fahrzeug weniger Unfälle ereignen, 
		da andernfalls der menschliche Fahrer typischerweise einer andauernden, monotonen Situation ausgesetzt würde. 
		Zum einen erfassen die Fahrzeuge durch eigene Sensoren ihre Umwelt und leiten entsprechende Reaktionen ein. 
		Zum anderen, worauf in diesem Projekt ein großes Augenmerk gelegt worden ist, kommuniziert das führende Fahrzeug mit den Mitgliedern seiner Kolonne über eine drahtlose Verbindung. 
		Erwartet wird, dass diese Kommunikation schneller durchgeführt wird als die Auswertung der Sensordaten jedes einzelnen Kolonnen-Teilnehmers. 
		In Folge dessen können die Sicherheitsabstände zwischen den Fahrzeugen signifikant geringer gehalten werden. 
	\section{Lastenheft} %(nicht-)funktionale anforderungen, was liefern wir am ende, use cases. nur grob erwähnen und dann im anhang auf das lastenheft verweisen??
	\section{Projekt-Organisation und Umfeld} % 3 teams arbeiten parallel, zusammenarbeit mit assystem und frauenhofer, wir: agiler Ansatz, clion, gitlab, slack, meistertask; späterer Umschwung auf gitlab issues
	% ros, turtle sim
	% externer Bau der autos plus betreuung durch externen studenten/frauenhofer/assystems
	% Räumlichkeiten: wo fand was statt
	\section{Projektplan} % vgl. project charter http://sce2.umkc.edu/BIT/burrise/pl/appendix/Software_Documentation_Templates/Project_Charter_Template.html
	%Meilensteine, Routinen, Treffen, Planänderungen (mal gucken was die anderen Gruppe da haben), Designänderungen der Architektur nach treffen mit assystem?
	\section{Projektablauf} %vergleich ist-zustand mit soll-zustand? was wurde bei den wöchentlichen treffen mit schlingloff etc besprochen, Lieferprobleme...
	% eventuell sind Projektmetriken interessant: Diagram zur Visualsierung der Zeitverteilung auf verschiedene Aspekte des Projekts (wie viel Zeit für's Coden, in ros einarbeiten etc)
\newpage
\part{Produktdokumentation}
	\section{Systemvoraussetzungen} % ubuntu, SW von assystems, ros. im prinzip beschreibung unserer vm + welche Schritte wurden unternommen ums zum laufen zu bringen und kurze erläuterung dass sw von assystems aufs board geschmissen wurde. und catkin zeugs
	\section{Fahrzeug-Architektur}
		\subsection{Hardware} % sensoren, boards, teile ausm 3d drucker, datenblätter im anhang? erläuterung von joe(?) wie er die boards zum laufen gebracht hat
		\subsection{Fahrzeugzusammenbau} % tutorial zum zusammenbau, fotos
	\section{Software-Architektur}
		\subsection{Architekturübersicht} % grafische Darstellung der Beziehung der module zueinander, uml?
		\subsection{Coding-Standard} % C++, Mix aus Google Style Guide und anderen Conventions, version control
		\subsection{Modulbeschreibung} % Beschreibung der Nodes inkl. (Aktivitäts-)Diagramme
			\subsubsection{Beispielnode A}
			\label{node_a}
				\paragraph{Aufgabe} Node A sammelt Daten bezüglich der aktuellen Radierfähigkeit verschiedener Radiergummis. Die Daten werden kontinuierlich ausgewertet, sodass bei Überschreitung von bestimmten, festgelegter Werte andere Nodes über die Änderung informiert werden. Der Quellcode ist im Anhang \ref{appendix:abcnode} hinterlegt. 
				
				\paragraph{Assoziationen} Zu den Subscribern gehören Node B (vgl. dazu \ref{node_b}) und Node C (ich tue so als ob ich hier eine Referenz einfüge). Die Publisher sind Node X, Y, und Z (Referenz und so, ne?).
				\begin{figure}[h!]
					\centering
					\caption{Prozesse von Node A, hat nicht unbedingt viel mit der vorhergehenden Beschreibung zu tun}
					\label{fig:node_a}
				\end{figure}
				
				\paragraph{Attribute} % nur die, die eurer Meinung nach relevant sind um die Methoden besser erklären zu können, auf jeden Fall kurz halten
				\begin{itemize}
					\item \textbf{A-Wert:} Speichert im Integer-Format den vorletzten, vom Topic \emph{Nieder mit den Tintenkillern} erhaltenen Wert.
					\item \textbf{B-Wert:} Speichert im Integer-Format den aktuellen, vom Topic \emph{Nieder mit den Tintenkillern} erhaltenen Wert.
				\end{itemize} 
				
				\paragraph{Methoden}
				
					\subparagraph{Z-Methode} Berechnet die Differenz zwischen dem A- und dem B-Wert. Überschreitet diese den Wert 7, wird ein String generiert und an die Subscriber des Topics \emph{Bleistiftgeflüster} geschickt, vlg. dazu Output von Node A.
					\subparagraph{Y-Methode} Sofern von der Z-Methode keine Überschreitung festgestellt worden ist, überschreibt die Y-Methode den A-Wert mit dem B-Wert und setzt an Stelle des B-Wertes den neu eingetroffenen Wert des Topics \emph{Nieder mit den Tintenkillern} ein. 
				
				\paragraph{Input} Node A ist Subscriber zum Topic \emph{Nieder mit den Tintenkillern} und empfängt im Integer-Format einen kontinuierlichen Datenstrom über die aktuelle Radierleistung. Die Daten werden von Sensor X geliefert. 
				
				% es werden sich vmtl. Themen aus dem Bereich 'Methoden' ueberschneiden
				\paragraph{Output} Node A ist Publisher zum Topic \emph{Bleistiftgeflüster} und verschickt Daten, die von der Z-Methode berechnet worden sind und einen bestimmten Wert überschritten haben. Die ausgehende Nachricht erfolgt im String-Format und kann von folgender Form sein:
				\begin{itemize}
					\item STR\_ACC
					\item STR\_ERR
					\item STR\_DEF
				\end{itemize}
				
			\subsubsection{Prioritization}
			\label{prioritization}
				\paragraph{Aufgabe} Der Prioritization-Node erhält Fahrdaten vom Platooning-Node und der MessageTranslation und entscheidet dann, wie sich das Fahrzeug zu verhalten hat. Er entscheidet also zwischen verschiedenen Steuersignalen, welches gerade benutzt werden soll. 
				\paragraph{Assoziationen} Der Prioritization-Node ist Subscriber vom Platooning-Node und dem MessageTranslation-Node. Er ist Publisher für den LongitudinalProcessing-Node und den LateralProcessing-Node. 
				\paragraph{Attribute}
					\begin{itemize}
						\item float \_speed\_ Die Geschwindigkeit, mit der das Auto fahren soll.
						\item float \_distance\_ Die Distanz, die innerhalb des Platoons zwischen den Fahrzeugen beibehalten werden soll. 
						\item float target\_angle\_ Der Winkel, auf den die Steuerung eingestellt werden soll.
						\item PrioritizationState state\_ Gibt an, in welchem Modus der Prioritization-Node derzeit ist. Der Modus gibt an, ob das Auto derzeit zum Beispiel die Fernsteuerung oder die Nachrichten aus dem Platoon priorisieren soll. 
					\end{itemize}
				\paragraph{Methoden}
					\subparagraph{hndl\_remotecontrolInput} Wird aufgerufen, wenn Daten der RemoteControl empfangen wurden und veröffentlicht diese via Topic, falls das Auto im State REMOTECONTROL ist.
					\subparagraph{hndl\_platooningToggle} Wird aufgerufen, wenn eine PlatooningToggleMessage empfangen wird. Setzt die Variable state\_ dann entsprechend auf PLATOONING. 
					\subparagraph{hndl\_platooningState} Wird aufgerufen, sobald eine PlatooningState Message empfangen wurde. Wenn state\_ auf Platooning gesetzt ist, sorgt die Methode dafür, dass das Auto als FV zur Kolonne aufschließt. ‘
				\paragraph{Input}
				    \begin{itemize}
				        \item remotecontrolInput von Node MessageTranslation
				        \item remotecontrolToggle von Node MessageTranslation 
				        \item platooningToggle von Node MessageTranslation 
				        \item platooningState von Node Platooning
				    \end{itemize}
				\paragraph{Output}
				    \begin{itemize}
				        \item targetSpeed an Node LongitudinalProcessing
				        \item targetDistance an Node LongitudinalProcessing
				        \item targetAngle an Node LateralProcessing
				    \end{itemize}
				
			\subsubsection{Platooning}
			\label{platooning}
				\paragraph{Aufgabe} Der Platooning-Node kommuniziert mit den anderen Fahrzeugen und tauscht mit diesen Daten aus. Zu den Daten gehören Geschwindigkeit des Platoons, die im Platoon einzuhaltende Distanz, Heartbeats sowie Broadcasts. 
				\paragraph{Assoziationen} Zu den Subscribern des Platooning-Node gehören der Prioritization-Node und der MessageTranslation-Node. Publisher für den Platooning-Node ist der MessageTranslation-Node. 
				\paragraph{Methoden}
					\subparagraph{} 
				\paragraph{Input} 
				    \begin{itemize}
    					\item platooningToggle von Node MessageTranslation
    					\item in/FV\_REQUEST von Node MessageTranslation
    					\item in/LV\_BROADCAST von Node MessageTranslation
    				\end{itemize}
				\paragraph{Output}
					\begin{itemize}
    					\item PlatooningState an Node Prioritization
    					\item out/FV\_REQUEST an Node MessageTranslation
    					\item out/LV\_BROADCAST an Node MessageTranslation
    				\end{itemize}
						
		    \subsubsection{User Interface}
			\label{controller_ui}
				\paragraph{Aufgabe} Der UserInterface-Node zeigt dem Nutzer aktuelle Daten des Fahrzeugs an. Dazu gehören zum Beispiel Nachrichten aus dem Platoon, Geschwindigkeit oder Distanz zu anderen Objekten. Aus diesen Daten soll der Nutzer nachvollziehen können, warum sich das Auto verhält, wie es sich verhält.
				\paragraph{Assoziationen} Der UserInterface-Node ist Subscriber vom UdpServer-Node.  
				\paragraph{Attribute}
					\begin{itemize}
					    \item Alle Attribute sind selbsterklaerend
					\end{itemize}
				\paragraph{Methoden}
					\subparagraph{hndl\_*} (Wobei * eine der verschiedenen Variablen oder Nachrichten ist) Für jede Variable (Wie zum Beispiel Geschwindigkeit, Beschleunigung etc.) gibt es im UserInterface-Node eine Methode. Die Methoden empfangen die jeweilige Variable und geben diese dann auf dem User Interface aus.
				\paragraph{Input}
				    \begin{itemize}
				        \item userInterfaceData von Node UdpServer
				    \end{itemize}
				\paragraph{Output}
				    \begin{itemize}
				        \item remoteControlInput an Node UdpServer
				        \item platooningToggle an Node UdpServer
				        \item remoteControlToggle an Node UdpServer
				    \end{itemize}
				    
			\subsubsection{UserInterfaceData}
			\label{user_interface_data}
				\paragraph{Aufgabe} Der UserInterfaceData-Node hält die Daten, die das UserInterface anzeigt, stets aktuell. Somit hat der Nutzer immer die aktuellsten Fahr-Daten vorliegen. 
				\paragraph{Assoziationen} Der UserInterfaceData-Node ist Subscriber von Messagetranslation. Er ist Publisher für UserInterface. 
				\paragraph{Attribute}
					\subparagraph{Platooning Messages}
				\paragraph{Methoden}
					\subparagraph{Tolle Methode A}
				\paragraph{Input}
				\paragraph{Output}
			
			\subsubsection{Message Translation}
			\label{message_translation}
				\paragraph{Aufgabe} Der MessageTranslation-Node ist dafür verantwortlich, Messages in Datentypen zu übersetzen, damit diese dann von den unterschiedlichen Nodes verwendet werden können. 
				\paragraph{Assoziationen} Der MessageTranslation-Node ist Subscriber vom RadioInterface-Node und dem Platooning-Node. Er ist Publisher für den UserInterface-Node, den RadioInterface-Node, den Platooning-Node und den Prioritization-Node. 
				\paragraph{Attribute}
					\subparagraph{Tolles Attribut A}
				\paragraph{Methoden}
					\subparagraph{Tolle Methode A}
				\paragraph{Input}
				\paragraph{Output}

			\subsubsection{Message Distribution}
			\label{controller_ui}
				\paragraph{Aufgabe} Der MessageDistribution-Node erhält alle einkommenden Nachrichten. Je nach MessageType werden diese Nachrichten dann vom MessageDistribution-Node auf den passenden Topics veröffentlicht. Dadurch erhalten alle Nodes immer die richtigen Nachrichten. 
				\paragraph{Assoziationen} ???
				\paragraph{Attribute}
				    \begin{itemize}
				        \item Alle Attribute sind selbsterklärend. 
				    \end{itemize}
				\paragraph{Methoden}
                    \subparagraph{hndl\_platooningIn} Erkennt, welche Art von Message empfangen wurde, dekodiert diese und veröffentlicht sie auf dem entsprechenden Topic. 
					\subparagraph{hndl\_lv\_broadcast} Verpackt die zu übertragenden Daten in eine LV\_BROADCAST-Nachricht und veröffentlicht diese an das Platoon. 
					\subparagraph{hndl\_lv\_accept} Verpackt die zu übertragenden Daten in eine LV\_ACCEPT-Nachricht und veröffentlicht diese an das Platoon.
					\subparagraph{hndl\_lv\_reject} Verpackt die zu übertragenden Daten in eine LV\_REJECT-Nachricht und veröffentlicht diese an das Platoon.
                	\subparagraph{hndl\_fv\_heartbeat} Verpackt die zu übertragenden Daten in eine FV\_HEARTBEAT-Nachricht und veröffentlicht diese an das Platoon.
                    \subparagraph{hndl\_fv\_leave} Verpackt die zu übertragenden Daten in eine FV\_LEAVE-Nachricht und veröffentlicht diese an das Platoon.
                	\subparagraph{hndl\_fv\_request} Verpackt die zu übertragenden Daten in eine FV\_REQEUEST-Nachricht und veröffentlicht diese an das Platoon.
                	\subparagraph{hndl\_ui} Verpackt die zu übertragenden Daten in eine REMOTE\_USERINTERFACE-Nachricht und veröffentlicht diese im Netzwerk. 
				\paragraph{Input} ???
				\paragraph{Output} ???

			\subsubsection{MessageTypes}
			\label{controller_ui}
				\paragraph{Aufgabe} ??
				\paragraph{Assoziationen}
				\paragraph{Attribute}
					\subparagraph{Tolles Attribut A}
				\paragraph{Methoden}

				\paragraph{Input}
				\paragraph{Output}

			\subsubsection{Distance Processing}
			\label{distance_processing}
				\paragraph{Aufgabe} Der DistanceProcessing-Node misst, wie weit er von den nächstgelegenen Objekten entfernt ist und stellt diese Information anderen Knoten zur Verfügung. 
				\paragraph{Assoziationen} Der DistanceProcessing-Node erhält seine Informationen von einem Ultraschall-Sensor. Er ist Publisher für den LongitudinalProcessing-Node.  
				\paragraph{Attribute}
					\subparagraph{Tolles Attribut A}
				\paragraph{Methoden}
					\subparagraph{Tolle Methode A}
				\paragraph{Input}
				\paragraph{Output}
			
			\subsubsection{Longitudinal Processing}
			\label{longitudinal_processing}
				\paragraph{Aufgabe} Der LongitudinalProcessing-Node ist für die Beschleunigung des Autos verantwortlich. Er erhält die gewünschte Geschwindigkeit aus dem Prioritization-Node und schickt dann die gewünschte Beschleunigung an den VehicleControl-Node. 
				\paragraph{Assoziationen} Der LongitudinalProcessing-Node ist Subscriber vom Prioritization-Node, dem DistancePreprocessing-Node und dem Speed Sensor. Er ist Publisher für den VehicleControl-Node. 
				\paragraph{Attribute}
					\subparagraph{Tolles Attribut A}
				\paragraph{Methoden}
					\subparagraph{Tolle Methode A}
				\paragraph{Input}
				\paragraph{Output}
						
			\subsubsection{Radio Interface}
			\label{radio_interface}
				\paragraph{Aufgabe} Der RadioInterface-Node wickelt den Nachrichtenverkehr über UDP ab. Er benutzt den UDP-Server, um das Senden und Empfangen von Netzwerk-Nachrichten über UDP zu ermöglichen. 
				\paragraph{Assoziationen} Der RadioInterface-Node ist 
				\paragraph{Attribute}
					\begin{itemize}
					    \item std::unique\_ptr<UdpServer> platooning\_server\_ptr\_ Ein einmaliger Pointer für den Platooning Server. 
					    \item std::unique\_ptr<UdpServer> controller\_server\_ptr\_ Ein einmaliger Pointer für den Controller Server. 
					\end{itemize}
				\paragraph{Methoden}
				    \subparagraph{hndl_platoonProtocolOut} Sendet Nachrichten in das Netzwerk. Je nach MessageType muss die Nachricht anders verschickt werden. Daher wird hierfür eine extra Methode benötigt. 
					\subparagraph{hndl\_radio\_receive} Kümmert sich um die empfangenen Nachrichten aus dem Netzwerk. Je nach MessageType muss mit den empfangenen Nachrichten anders verfahren werden. Darum kümmmert sich diese Methode. 
				\paragraph{Input} 
				    \begin{itemize}
				        \item in/platooningProtocol von Node MessageTranslation
				        \item Daten vom UdpServer
				    \end{itemize}
				\paragraph{Output}
				    \begin{itemize}
				        \item out/platooningProtocol an Node MessageTranslation
				        \item Daten an UdpServer
				    \end{itemize}
				
		    \subsubsection{UdpServer}
			\label{controller_ui}
				\paragraph{Aufgabe} Der UdpServer-Node wird vom RadioInterface-Node verwendet, um den Nachrichtenverkehr über das Netzwerk realisieren zu können. 
				\paragraph{Assoziationen} Der UdpServer-Node ist Subscriber vom UserInterface-Node und Publisher für den UserInterface-Node. 
				\paragraph{Attribute}
					\subparagraph{Tolles Attribut A}
				\paragraph{Methoden}
					\subparagraph{Tolle Methode A}
				\paragraph{Input}
				\paragraph{Output}
				
			\subsubsection{Toller neuer Node}
			\label{controller_ui}
				\paragraph{Aufgabe}
				\paragraph{Assoziationen}
				\paragraph{Attribute}
					\subparagraph{Tolles Attribut A}
				\paragraph{Methoden}
					\subparagraph{Tolle Methode A}
				\paragraph{Input}
				\paragraph{Output}			
				
	\section{Tests}
		\subsection{Test-Standard} % warum haben wir uns auf google test festgelegt; Designentscheidung
		\subsection{Test-Cases}
		\subsection{Testergebnisse}
	\section{Nutzerhandbuch} %brumm brumm auto fahren (wie lasse ich=schlingloff die autos fahren/kann ich die simulation starten? was kann ich alles anstellen und wie? steuerung, hindernisse...)
\newpage
\part{Beschreibung der Eigenleistung}
	\section{Cooles Kind 1}
		Für nähere Informationen siehe Anhang \ref{appendix:xynode}.
	\section{Falco Becker}
	\section{Yannick Boerner}
	\section{Anne Borchard}
	\section{Franz Eichberg}
	\section{Jonas Heyden}
	\section{Benjamin Lorenz}
	\section{Stephan Orlowsky}

%Anhang: 
%Datenblätter
%Code
%Spezifikationen aus dem Orga Repo
%
\renewcommand\appendixtocname{Anhang} % sonst stünde da 'appendices'
\renewcommand\appendixpagename{Anhang}
\renewcommand\appendixname{Anhang}

\begin{appendices}

\section{XY-Node Code}
\label{appendix:xynode}
	Hier der Code zum Node XY...

\section{Code in Latex-Dokument kopiert}
\label{appendix:abcnode}  
	\begin{lstlisting}[style=customcpp]
	class Animal 
	{
		int x_value;
	public:
		int y_value;
		int x = 42;
	};
	
	class Dog : public Animal 
	{}; \end{lstlisting}

% cpp-file befindet sich im gleichen Ordner wie das tex-file
% der Stil wird global definiert, siehe oben customcpp
\section{Code per File importiert}
\label{appendix:importcode}
	\lstinputlisting[style=customcpp]{lambda_test.cpp}
\end{appendices}
\end{document}
