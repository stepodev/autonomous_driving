\documentclass[a4paper, 12pt, titlepage]{scrartcl}  
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage[toc,title,page]{appendix} % Anhang 

\usepackage{listings}  % zum Codeeinbinden, Doku: http://users.ecs.soton.ac.uk/srg/softwaretools/document/start/listings.pdf
\lstdefinestyle{customcpp}{
	belowcaptionskip=1\baselineskip,
	title=\lstname,
	breaklines=true,
	keepspaces=true, 
	flexiblecolumns=true,
	tabsize=2, % ein tab = 2 spaces
	numbers=left,
	frame=leftline,
	language=C++,
	showstringspaces=false 
}

\pagenumbering{arabic} 
\usepackage{graphicx}
\usepackage[onehalfspacing]{setspace}
\usepackage[left=3cm,right=3cm,top=2.5cm,bottom=2.5cm,includeheadfoot]{geometry}

\begin{document}	
\author{Supercoole Kinder}
\title{Projektdokumentation} 
\publishers{Humboldt-Universit\"at zu Berlin}
\maketitle
\tableofcontents

\part{Projektdokumentation}
	\section{Projektbeschreibung} % Ziele und Motivation, warum das alles so toll ist. (umweltfreundlich, super Auslastung, weniger Unfälle... besonderes feature: car2car kommunikation)
		Im Rahmen des Semesterprojekts 'Hochautomatisiertes Fahren' an der Humboldt-Universität zu Berlin haben sich mehrere Studenten, verteilt auf drei parallel arbeitende Gruppen, mit dem Problem beschäftigt, drei Modellfahrzeuge automatisiert in einer Kolonne fahren zu lassen. Dabei gibt das führende Fahrzeug Geschwindigkeit und Richtung vor. Der Gedanke hinter dieser Problemstellung ist, den Verkehrsfluss in Szenarien wie zum Beispiel auf der Autobahn effizienter und sicherer zu gestalten. Im Idealfall spart die Kolonnen-Fahrweise aufgrund der Ausnutzung des Windschattens Ressourcen wie Benzin. Zudem wird erhofft, dass sich durch die zeitweilige Übernahme der Steuerung durch das Fahrzeug weniger Unfälle ereignen, da andernfalls der menschliche Fahrer typischerweise einer andauernden, monotonen Situation ausgesetzt würde. Zum einen erfassen die Fahrzeuge durch eigene Sensoren ihre Umwelt und leiten entsprechende Reaktionen ein. Zum anderen, worauf in diesem Projekt ein großes Augenmerk gelegt worden ist, kommuniziert das führende Fahrzeug mit den Mitgliedern seiner Kolonne über eine drahtlose Verbindung. Erwartet wird, dass diese Kommunikation schneller durchgeführt wird als die Auswertung der Sensordaten jedes einzelnen Kolonnen-Teilnehmers. In Folge dessen können die Sicherheitsabstände zwischen den Fahrzeugen signifikant geringer gehalten werden. 
	\section{Lastenheft} %(nicht-)funktionale anforderungen, was liefern wir am ende, use cases. nur grob erwähnen und dann im anhang auf das lastenheft verweisen??
	\section{Projekt-Organisation und Umfeld} % 3 teams arbeiten parallel, zusammenarbeit mit assystem und frauenhofer, wir: agiler Ansatz, clion, gitlab, slack, meistertask; späterer Umschwung auf gitlab issues
	% ros, turtle sim
	% externer Bau der autos plus betreuung durch externen studenten/frauenhofer/assystems
	% Räumlichkeiten: wo fand was statt
	\section{Projektplan} % vgl. project charter http://sce2.umkc.edu/BIT/burrise/pl/appendix/Software_Documentation_Templates/Project_Charter_Template.html
	%Meilensteine, Routinen, Treffen, Planänderungen (mal gucken was die anderen Gruppe da haben), Designänderungen der Architektur nach treffen mit assystem?
	\section{Projektablauf} %vergleich ist-zustand mit soll-zustand? was wurde bei den wöchentlichen treffen mit schlingloff etc besprochen, Lieferprobleme...
	% eventuell sind Projektmetriken interessant: Diagram zur Visualsierung der Zeitverteilung auf verschiedene Aspekte des Projekts (wie viel Zeit für's Coden, in ros einarbeiten etc)
\newpage
\part{Produktdokumentation}
	\section{Systemvoraussetzungen} % ubuntu, SW von assystems, ros. im prinzip beschreibung unserer vm + welche Schritte wurden unternommen ums zum laufen zu bringen und kurze erläuterung dass sw von assystems aufs board geschmissen wurde. und catkin zeugs
	\section{Fahrzeug-Architektur}
		\subsection{Hardware} % sensoren, boards, teile ausm 3d drucker, datenblätter im anhang? erläuterung von joe(?) wie er die boards zum laufen gebracht hat
		\subsection{Fahrzeugzusammenbau} % tutorial zum zusammenbau, fotos
	\section{Software-Architektur}
		\subsection{Architekturübersicht} % grafische Darstellung der Beziehung der module zueinander, uml?
		\subsection{Coding-Standard} % C++, Mix aus Google Style Guide und anderen Conventions, version control
		\subsection{Modulbeschreibung} % Beschreibung der Nodes inkl. (Aktivitäts-)Diagramme
			\subsubsection{Beispielnode A}
			\label{node_a}
				\paragraph{Aufgabe} Node A sammelt Daten bezüglich der aktuellen Radierfähigkeit verschiedener Radiergummis. Die Daten werden kontinuierlich ausgewertet, sodass bei Überschreitung von bestimmten, festgelegter Werte andere Nodes über die Änderung informiert werden. Der Quellcode ist im Anhang \ref{appendix:abcnode} hinterlegt. 
				
				\paragraph{Assoziationen} Zu den Subscribern gehören Node B (vgl. dazu \ref{node_b}) und Node C (ich tue so als ob ich hier eine Referenz einfüge). Die Publisher sind Node X, Y, und Z (Referenz und so, ne?).
				\begin{figure}[h!]
					\centering
					\caption{Prozesse von Node A, hat nicht unbedingt viel mit der vorhergehenden Beschreibung zu tun}
					\label{fig:node_a}
				\end{figure}
				
				\paragraph{Attribute} % nur die, die eurer Meinung nach relevant sind um die Methoden besser erklären zu können, auf jeden Fall kurz halten
				\begin{itemize}
					\item \textbf{A-Wert:} Speichert im Integer-Format den vorletzten, vom Topic \emph{Nieder mit den Tintenkillern} erhaltenen Wert.
					\item \textbf{B-Wert:} Speichert im Integer-Format den aktuellen, vom Topic \emph{Nieder mit den Tintenkillern} erhaltenen Wert.
				\end{itemize} 
				
				\paragraph{Methoden}
				
					\subparagraph{Z-Methode} Berechnet die Differenz zwischen dem A- und dem B-Wert. Überschreitet diese den Wert 7, wird ein String generiert und an die Subscriber des Topics \emph{Bleistiftgeflüster} geschickt, vlg. dazu Output von Node A.
					\subparagraph{Y-Methode} Sofern von der Z-Methode keine Überschreitung festgestellt worden ist, überschreibt die Y-Methode den A-Wert mit dem B-Wert und setzt an Stelle des B-Wertes den neu eingetroffenen Wert des Topics \emph{Nieder mit den Tintenkillern} ein. 
				
				\paragraph{Input} Node A ist Subscriber zum Topic \emph{Nieder mit den Tintenkillern} und empfängt im Integer-Format einen kontinuierlichen Datenstrom über die aktuelle Radierleistung. Die Daten werden von Sensor X geliefert. 
				
				% es werden sich vmtl. Themen aus dem Bereich 'Methoden' ueberschneiden
				\paragraph{Output} Node A ist Publisher zum Topic \emph{Bleistiftgeflüster} und verschickt Daten, die von der Z-Methode berechnet worden sind und einen bestimmten Wert überschritten haben. Die ausgehende Nachricht erfolgt im String-Format und kann von folgender Form sein:
				\begin{itemize}
					\item STR\_ACC
					\item STR\_ERR
					\item STR\_DEF
				\end{itemize}
			
			\subsubsection{Vehicle Control}
			\label{vehicle_control}
				\paragraph{Aufgabe} Der VehicleControl-Node ist dafür da, das Fahrzeug zu steuern. Dies tut er, in dem er konkrete Steuersignale an den Motor und die Lenkung schickt. 
				\paragraph{Assoziationen} Der VehicleControl-Node ist Subscriber des LongitudinalProcessing-Node und des LateralProcessing-Node. Er steuert direkt den Motor und die Lenkung an. 
				\paragraph{Attribute}
					\subparagraph{Tolles Attribut A}
				\paragraph{Methoden}
					\subparagraph{Tolle Methode A}
				\paragraph{Input}
				\paragraph{Output}
			
			\subsubsection{Distance Processing}
			\label{distance_processing}
				\paragraph{Aufgabe} Der DistanceProcessing-Node misst, wie weit er von den nächstgelegenen Objekten entfernt ist und stellt diese Information anderen Knoten zur Verfügung. 
				\paragraph{Assoziationen} Der DistanceProcessing-Node erhält seine Informationen von einem Ultraschall-Sensor. Er ist Publisher für den LongitudinalProcessing-Node.  
				\paragraph{Attribute}
					\subparagraph{Tolles Attribut A}
				\paragraph{Methoden}
					\subparagraph{Tolle Methode A}
				\paragraph{Input}
				\paragraph{Output}
			
			\subsubsection{Lane Detect}
			\label{lane_detect}
				\paragraph{Aufgabe} Der LaneDetect-Node erkennt die Fahrbahnmarkierungen und stellt Informationen über die Lage der Fahrbahn zur Verfügung. 
				\paragraph{Assoziationen} Der LaneDetect-Node erhält ein Bild von der Kamera. Er ist Publisher für den LateralProcessing-Node. 
				\paragraph{Attribute}
					\subparagraph{Tolles Attribut A}
				\paragraph{Methoden}
					\subparagraph{Tolle Methode A}
				\paragraph{Input}
				\paragraph{Output}
			
			\subsubsection{Longitudal Processing}
			\label{longitudal_processing}
				\paragraph{Aufgabe}
				\paragraph{Assoziationen}
				\paragraph{Attribute}
					\subparagraph{Tolles Attribut A}
				\paragraph{Methoden}
					\subparagraph{Tolle Methode A}
				\paragraph{Input}
				\paragraph{Output}
			
			\subsubsection{Lateral Processing}
			\label{lateral_processing}
				\paragraph{Aufgabe}
				\paragraph{Assoziationen}
				\paragraph{Attribute}
					\subparagraph{Tolles Attribut A}
				\paragraph{Methoden}
					\subparagraph{Tolle Methode A}
				\paragraph{Input}
				\paragraph{Output}
				
			\subsubsection{Prioritization}
			\label{prioritization}
				\paragraph{Aufgabe} Der Prioritization-Node erhält Fahrdaten vom Platooning-Node und der MessageTranslation und entscheidet dann, wie sich das Fahrzeug zu verhalten hat. Er entscheidet also zwischen verschiedenen Steuersignalen, welches gerade benutzt werden soll. 
				\paragraph{Assoziationen} Der Prioritization-Node ist Subscriber vom Platooning-Node und dem MessageTranslation-Node. Er ist Publisher für den LongitudinalProcessing-Node und den LateralProcessing-Node. 
				\paragraph{Attribute}
					\subparagraph{Tolles Attribut A}
				\paragraph{Methoden}
					\subparagraph{Tolle Methode A}
				\paragraph{Input}
				\paragraph{Output}
				
			\subsubsection{Platooning}
			\label{platooning}
				\paragraph{Aufgabe} Der Platooning-Node kommuniziert mit den anderen Fahrzeugen und tauscht mit diesen Daten aus. Zu den Daten gehören Geschwindigkeit des Platoons, die im Platoon einzuhaltende Distanz, Heartbeats sowie Broadcasts. 
				\paragraph{Assoziationen} Zu den Subscribern des Platooning-Node gehören der Prioritization-Node und der MessageTranslation-Node. Publisher für den Platooning-Node ist der MessageTranslation-Node. 

				\paragraph{Methoden}
					\subparagraph{PlatoonProtocolInHandler()} Diese Methode ist dafür da, eintreffende Messages zu verarbeiten. Sobald der Platooning-Node eine Message erhält, wird diese Methode aufgerufen. Anhand eines switch-cases wird erkannt, welche Art von Message erhalten wurde. Anschließend wird die passende DecodeIncomingJson-Methode aufgerufen. Nachdem die Nachricht dekodiert wurde, werden die dekodierten Daten an den entsprechenden Node gesendet. 
					\subparagraph{DecodeIncomingJson()} Diese Methode ist eine Helfermethode für PlatoonProtocolInHandler. Sie wird überladen, denn die unterschiedlichen MessageTypes müssen unterschiedlich ausgelesen werden. Ihre Aufgabe ist es, die ankommende JSON-Nachricht richtig zu dekodieren und dem PlatoonProtocolInHandler dadurch Informationen bereitzustellen. 
				\paragraph{Input} 
				    \begin{itemize}
    					\item platooningToggle von Node MessageTranslation
    					\item in/FV\_REQUEST von Node MessageTranslation
    					\item in/LV\_BROADCAST von Node MessageTranslation
    				\end{itemize}
				\paragraph{Output}
					\begin{itemize}
    					\item PlatooningState an Node Prioritization
    					\item out/FV\_REQUEST an Node MessageTranslation
    					\item out/LV\_BROADCAST an Node MessageTranslation
    				\end{itemize}
			
			\subsubsection{UserInterfaceData}
			\label{user_interface_data}
				\paragraph{Aufgabe} Der UserInterfaceData-Node zeigt dem Nutzer aktuelle Daten des Fahrzeugs an. Dazu gehören zum Beispiel Nachrichten aus dem Platoon, Geschwindigkeit oder Distanz zu anderen Objekten. Aus diesen Daten soll der Nutzer nachvollziehen können, warum sich das Auto verhält, wie es sich verhält.
				\paragraph{Assoziationen} Der UserInterfaceData-Node ist Subscriber von Messagetranslation. Er ist kein Publisher.
				\paragraph{Attribute}
					\subparagraph{Platooning Messages}
				\paragraph{Methoden}
					\subparagraph{Tolle Methode A}
				\paragraph{Input}
				\paragraph{Output}
			
			\subsubsection{Message Translation}
			\label{message_translation}
				\paragraph{Aufgabe} Der MessageTranslation-Node ist dafür verantwortlich, Messages in Datentypen zu übersetzen, damit diese dann von den unterschiedlichen Nodes verwendet werden können. 
				\paragraph{Assoziationen} Der MessageTranslation-Node ist Subscriber vom RadioInterface-Node und dem Platooning-Node. Er ist Publisher für den UserInterface-Node, den RadioInterface-Node, den Platooning-Node und den Prioritization-Node. 
				\paragraph{Attribute}
					\subparagraph{Tolles Attribut A}
				\paragraph{Methoden}
					\subparagraph{Tolle Methode A}
				\paragraph{Input}
				\paragraph{Output}
			
			\subsubsection{Radio Interface}
			\label{radio_interface}
				\paragraph{Aufgabe} Der RadioInterface-Node
				\paragraph{Assoziationen}
				\paragraph{Attribute}
					\subparagraph{Tolles Attribut A}
				\paragraph{Methoden}
					\subparagraph{Tolle Methode A}
				\paragraph{Input}
				\paragraph{Output}
			
			\subsubsection{Controller UI}
			\label{controller_ui}
				\paragraph{Aufgabe}
				\paragraph{Assoziationen}
				\paragraph{Attribute}
					\subparagraph{Tolles Attribut A}
				\paragraph{Methoden}
					\subparagraph{Tolle Methode A}
				\paragraph{Input}
				\paragraph{Output}
				
			\subsubsection{Message Distribution}
			\label{controller_ui}
				\paragraph{Aufgabe} Der MessageDistribution Node verteilt die unterschiedlichen Messages an die dafür vorhergesehenen Nodes. 
				\paragraph{Assoziationen}
				\paragraph{Attribute}
					\subparagraph{Tolles Attribut A}
				\paragraph{Methoden}
					\subparagraph{Tolle Methode A}
				\paragraph{Input}
				\paragraph{Output}
				
			\subsubsection{MessageTypes}
			\label{controller_ui}
				\paragraph{Aufgabe}
				\paragraph{Assoziationen}
				\paragraph{Attribute}
					\subparagraph{Tolles Attribut A}
				\paragraph{Methoden}
					\subparagraph{Tolle Methode A}
				\paragraph{Input}
				\paragraph{Output}
				
		    \subsubsection{UdpServer}
			\label{controller_ui}
				\paragraph{Aufgabe}
				\paragraph{Assoziationen}
				\paragraph{Attribute}
					\subparagraph{Tolles Attribut A}
				\paragraph{Methoden}
					\subparagraph{Tolle Methode A}
				\paragraph{Input}
				\paragraph{Output}
			
	\section{Tests}
		\subsection{Test-Standard} % warum haben wir uns auf google test festgelegt; Designentscheidung
		\subsection{Test-Cases}
		\subsection{Testergebnisse}
	\section{Nutzerhandbuch} %brumm brumm auto fahren (wie lasse ich=schlingloff die autos fahren/kann ich die simulation starten? was kann ich alles anstellen und wie? steuerung, hindernisse...)
\newpage
\part{Beschreibung der Eigenleistung}
	\section{Cooles Kind 1}
		Für nähere Informationen siehe Anhang \ref{appendix:xynode}.
	\section{Falco Becker}
	\section{Yannick Boerner}
	\section{Anne Borchard}
	\section{Franz Eichberg}
	\section{Jonas Heyden}
	\section{Benjamin Lorenz}
	\section{Stephan Orlowsky}

%Anhang: 
%Datenblätter
%Code
%Spezifikationen aus dem Orga Repo
%
\renewcommand\appendixtocname{Anhang} % sonst stünde da 'appendices'
\renewcommand\appendixpagename{Anhang}
\renewcommand\appendixname{Anhang}

\begin{appendices}

\section{XY-Node Code}
\label{appendix:xynode}
	Hier der Code zum Node XY...

\section{Code in Latex-Dokument kopiert}
\label{appendix:abcnode}  
	\begin{lstlisting}[style=customcpp]
	class Animal 
	{
		int x_value;
	public:
		int y_value;
		int x = 42;
	};
	
	class Dog : public Animal 
	{}; \end{lstlisting}

% cpp-file befindet sich im gleichen Ordner wie das tex-file
% der Stil wird global definiert, siehe oben customcpp
\section{Code per File importiert}
\label{appendix:importcode}
	\lstinputlisting[style=customcpp]{lambda_test.cpp}
\end{appendices}
\end{document}
